package jku.se.Controller;

import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.control.*;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import jku.se.InvoiceStatus;
import jku.se.InvoiceType;
import jku.se.Refund;

import java.io.IOException;
import java.sql.Date;
import java.sql.SQLException;
import java.time.LocalDate;
import java.util.Optional;

import static jku.se.Database.*;
import static jku.se.InvoiceScan.isWorkday;

public class EditInvoiceUserController extends Controller{
    @FXML
    public Label labelRechnungsID;
    @FXML
    public ComboBox comboBoxTyp;
    @FXML
    public TextField textfieldUsername;
    @FXML
    public ComboBox comboBoxStatus;
    @FXML
    public TextField textfieldImage;
    @FXML
    public TextField textfieldRefund;
    @FXML
    public TextField textFieldBetrag;
    @FXML
    public DatePicker datePickerDatum;

    private int invoiceId;
    private double amount;
    private String date;
    private String typ;
    private String user;

    @FXML
    public void initialize() {
        comboBoxTyp.getItems().addAll(
                InvoiceType.SUPERMARKET.name(),
                InvoiceType.RESTAURANT.name()
        );

    }

    @FXML
    public void saveChangesUser() throws IOException, SQLException {
        // Hole die bearbeiteten Werte aus den Textfeldern und speichere sie in der Datenbank
        int id = Integer.parseInt(labelRechnungsID.getText());
        double betrag = Double.parseDouble(textFieldBetrag.getText());
        Date datum = null;

        try {
            datum = Date.valueOf(datePickerDatum.getValue());
        } catch (IllegalArgumentException exc) {
            showAlert("Error", "Please enter a valid date in the format yyyy-mm-dd.");
            return; // Update wird abgebrochen, falls das Datum ungültig ist
        }

        if(!isWorkday(datum.toLocalDate())){
            showAlert("Error", "The chosen date is not a working day!"); //ist kein Arbeitstag
            return;
        }

        String typString = (String) comboBoxTyp.getValue();

        if (betrag < 0) {
            // negativer Rechnungsbetrag
            showAlert("Error", "Negative Beträge sind nicht erlaubt!");
            return; // Update wird abgebrochen
        }

        InvoiceType typ = InvoiceType.valueOf((String) comboBoxTyp.getValue());
        String username = getInvoiceUsername(id);
        InvoiceStatus status = InvoiceStatus.valueOf(getInvoiceStatus(id));
        String image = getInvoiceImage(id);
        double refund = 0;
        if(typString.equals(String.valueOf(InvoiceType.SUPERMARKET))){
            refund = Refund.getRefundSupermarket();
        } else {
            refund = Refund.getRefundRestaurant();
        }

        boolean success = updateInvoice(betrag, datum, typ, username, status, image, refund, id);
        if (success) {
            showAlertSuccess("Erfolg", "Rechnung wurde erfolgreich aktualisiert. Folgende Werte sind nun eingetragen:" +
                    "\nID: " + id +
                    "\nBetrag: " + betrag +
                    "\nDatum: " + datum + //Status wurde hier rausgenommen, wegen Platzgründen in der Erfolgsnachricht
                    "\nStatus: " + status +
                    "\nRefund: " + refund);
        } else {
            showAlert("Fehler", "Rechnung konnte nicht aktualisiert werden.");
        }
    }

    // Methode zum Anzeigen von Fehlerbenachrichtigungen (Alert)
    public void showAlert(String title, String message) { //generated by AI
        Alert alert = new Alert(Alert.AlertType.ERROR);  // oder AlertType.INFORMATION je nach Bedarf
        alert.setTitle(title);
        alert.setHeaderText("Error");  // Optional: Header Text entfernen
        alert.setContentText(message);
        alert.showAndWait();
    }

    public void showAlertSuccess(String title, String message) { //generated by AI
        Alert alert = new Alert(Alert.AlertType.INFORMATION);  // oder AlertType.INFORMATION je nach Bedarf
        alert.setTitle(title);
        alert.setHeaderText("Success");
        ImageView successIcon = new ImageView(new Image("file:src/test/resources/check_mark.png"));

        successIcon.setFitWidth(20);
        successIcon.setFitHeight(20);
        alert.setGraphic(successIcon);  // Dein grünes Häkchen-Icon hier
        alert.setContentText(message);
        alert.showAndWait();
    }

    public void setInvoice(int id, double amount, String typ, String date, String user) { //Wird für Ausfüllung von fxml Spalten benötigt
        this.invoiceId = id;
        this.amount = amount;
        this.typ = typ;
        this.date = date;
        this.user = user; //wird nur benötigt falls die datei gelöscht wird
        labelRechnungsID.setText(String.valueOf(id));
        textFieldBetrag.setText(String.valueOf(amount));
        comboBoxTyp.setValue(String.valueOf(typ));
        //Um das Datumsfeld zu befüllen mit dem erstellten datum
        LocalDate choosendate = LocalDate.parse(this.date);
            datePickerDatum.setDayCellFactory(picker -> new DateCell() {
                @Override
                public void updateItem(LocalDate date, boolean empty) {
                    super.updateItem(date, empty);
                    setDisable(empty || date.isAfter(LocalDate.now()));
                }
            });
            datePickerDatum.setValue(choosendate);
    }

    @FXML
    private void goBackToInvoicesUser(javafx.event.ActionEvent event) throws IOException{
        switchScene(event, "submittedBills.fxml");

    }

    @FXML
    private void handleDeleteInvoiceUser() throws SQLException {
        Alert alert = new Alert(Alert.AlertType.CONFIRMATION);
        alert.setTitle("Delete Confirmation");
        alert.setHeaderText(null);
        alert.setContentText("Are you sure you want to delete this invoice?");

        Optional<ButtonType> result = alert.showAndWait();
        if (result.isPresent() && result.get() == ButtonType.OK) {
            deleteInvoice(getConnection(), user, LocalDate.parse(date));//globale user variable, weil kann bei User nicht aus Textfield hergenommen werden
        }
    }

}
